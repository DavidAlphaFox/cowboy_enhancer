<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module database_manager</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module database_manager</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   This module manages the direct actions over the database backends,
   it is also a generic interface to it.
<p>Copyright Â© (C) 2015, Ivanco Software Corporation</p>

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>
<p><b>Authors:</b> Ivan Carmenates Garcia.</p>

<h2><a name="description">Description</a></h2>
   This module manages the direct actions over the database backends,
   it is also a generic interface to it.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-condition_term">condition_term()</a></h3>
<p><tt>condition_term() = {<a href="#type-field_name">field_name()</a> | <a href="#type-full_field_name">full_field_name()</a> | <a href="#type-field_value">field_value()</a>, <a href="#type-operator">operator()</a>, <a href="#type-field_name">field_name()</a> | <a href="#type-full_field_name">full_field_name()</a> | <a href="#type-field_value">field_value()</a>}</tt></p>


<h3 class="typedecl"><a name="type-db_session">db_session()</a></h3>
<p><tt>db_session() = {Backend::atom(), Connection::any()}</tt></p>


<h3 class="typedecl"><a name="type-field_name">field_name()</a></h3>
<p><tt>field_name() = atom()</tt></p>


<h3 class="typedecl"><a name="type-field_name_alias">field_name_alias()</a></h3>
<p><tt>field_name_alias() = atom()</tt></p>


<h3 class="typedecl"><a name="type-field_value">field_value()</a></h3>
<p><tt>field_value() = term()</tt></p>


<h3 class="typedecl"><a name="type-full_field_name">full_field_name()</a></h3>
<p><tt>full_field_name() = {<a href="#type-table_name">table_name()</a>, <a href="#type-field_name">field_name()</a>} | {<a href="#type-table_name">table_name()</a>, <a href="#type-field_name">field_name()</a>, <a href="#type-field_name_alias">field_name_alias()</a>}</tt></p>


<h3 class="typedecl"><a name="type-full_return_field_specs">full_return_field_specs()</a></h3>
<p><tt>full_return_field_specs() = [<a href="#type-field_name">field_name()</a> | {<a href="#type-table_name">table_name()</a>, <a href="#type-field_name">field_name()</a>} | {<a href="#type-table_name">table_name()</a>, [<a href="#type-field_name">field_name()</a>, ...]}, ...]</tt></p>


<h3 class="typedecl"><a name="type-group_by_expr">group_by_expr()</a></h3>
<p><tt>group_by_expr() = [<a href="#type-field_value">field_value()</a> | <a href="#type-full_field_name">full_field_name()</a>, ...]</tt></p>


<h3 class="typedecl"><a name="type-logic_operator">logic_operator()</a></h3>
<p><tt>logic_operator() = 'and' | 'or'</tt></p>


<h3 class="typedecl"><a name="type-map_result_data">map_result_data()</a></h3>
<p><tt>map_result_data() = no_data | #{} | [#{}, ...]</tt></p>


<h3 class="typedecl"><a name="type-match_field_specs">match_field_specs()</a></h3>
<p><tt>match_field_specs() = [<a href="#type-condition_term">condition_term()</a>, ...] | list() | #{}</tt></p>


<h3 class="typedecl"><a name="type-operator">operator()</a></h3>
<p><tt>operator() = gt | '&gt;' | lt | '&lt;' | gte | '&gt;=' | lte | '=&lt;' | eq | '==' | ne | '/=' | like</tt></p>


<h3 class="typedecl"><a name="type-order_by_expr">order_by_expr()</a></h3>
<p><tt>order_by_expr() = [<a href="#type-field_value">field_value()</a> | <a href="#type-full_field_name">full_field_name()</a> | {<a href="#type-field_name">field_name()</a> | <a href="#type-full_field_name">full_field_name()</a>, asc | desc}, ...]</tt></p>


<h3 class="typedecl"><a name="type-proplist_result_data">proplist_result_data()</a></h3>
<p><tt>proplist_result_data() = [] | [<a href="proplists.html#type-proplist">proplists:proplist()</a>, ...]</tt></p>


<h3 class="typedecl"><a name="type-query_params">query_params()</a></h3>
<p><tt>query_params() = [any(), ...] | []</tt></p>


<h3 class="typedecl"><a name="type-raw_result_data">raw_result_data()</a></h3>
<p><tt>raw_result_data() = any()</tt></p>


<h3 class="typedecl"><a name="type-result_data">result_data()</a></h3>
<p><tt>result_data() = <a href="#type-map_result_data">map_result_data()</a> | <a href="#type-proplist_result_data">proplist_result_data()</a> | <a href="#type-raw_result_data">raw_result_data()</a></tt></p>


<h3 class="typedecl"><a name="type-result_data_for_insert">result_data_for_insert()</a></h3>
<p><tt>result_data_for_insert() = #{} | [<a href="proplists.html#type-proplist">proplists:proplist()</a>] | any()</tt></p>


<h3 class="typedecl"><a name="type-simple_return_field_specs">simple_return_field_specs()</a></h3>
<p><tt>simple_return_field_specs() = [<a href="#type-field_name">field_name()</a>, ...]</tt></p>


<h3 class="typedecl"><a name="type-table_name">table_name()</a></h3>
<p><tt>table_name() = atom()</tt></p>


<h3 class="typedecl"><a name="type-table_spec">table_spec()</a></h3>
<p><tt>table_spec() = {<a href="#type-table_name">table_name()</a>, #{}}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#connect-1">connect/1</a></td><td>
  Tries to connect to a database backend.</td></tr>
<tr><td valign="top"><a href="#connect-2">connect/2</a></td><td>
  Tries to connect to a database backend within a <code>Timeout</code>.</td></tr>
<tr><td valign="top"><a href="#connection_block-1">connection_block/1</a></td><td>
  Tries to create a connection session with an available connection
  from the connection pool for the <code>main_backend</code> backend, and
  executes the function in <code>Fun</code> passing <code>DBSession</code> as argument.</td></tr>
<tr><td valign="top"><a href="#connection_block-2">connection_block/2</a></td><td>
  Tries to create connection session with an available connection
  from the connection pool for the specified <code>BackendName</code> in
  <code>Options</code>, and executes the function in <code>Fun</code> passing <code>DBSession</code>  
as argument.</td></tr>
<tr><td valign="top"><a href="#connection_block_transaction-1">connection_block_transaction/1</a></td><td>
  Tries to create a connection session and a database transaction
  context with an available connection from the connection pool for
  the <code>main_backend</code> backend, and executes the function in <code>Fun</code>
  passing <code>DBSession</code> as argument.</td></tr>
<tr><td valign="top"><a href="#connection_block_transaction-2">connection_block_transaction/2</a></td><td>
  Tries to create a connection session and a database transaction
  context with an available connection from the connection pool for
  the specified <code>BackendName</code> in <code>Options</code>, and executes the function
  in <code>Fun</code> passing <code>DBSession</code> as argument.</td></tr>
<tr><td valign="top"><a href="#delete-3">delete/3</a></td><td>
  Deletes data from a database using a <code>TableName</code> and
  <code>MatchFieldSpecs</code> parameters.</td></tr>
<tr><td valign="top"><a href="#delete-4">delete/4</a></td><td>
  Deletes data from a database using a <code>TableName</code>, <code>MatchFieldSpecs</code>
  and <code>Options</code> parameters.</td></tr>
<tr><td valign="top"><a href="#disconnect-1">disconnect/1</a></td><td>
  Disconnects from the specified <code>DBSession</code>.</td></tr>
<tr><td valign="top"><a href="#find-3">find/3</a></td><td>
  Finds data in a database using <code>TableNames</code> and <code>MatchFieldSpecs</code>  
parameters.</td></tr>
<tr><td valign="top"><a href="#find-4">find/4</a></td><td>
  Finds data in a database using <code>TableNames</code>, <code>MatchFieldSpecs</code> and
  <code>Options</code> parameters.</td></tr>
<tr><td valign="top"><a href="#find_one-3">find_one/3</a></td><td>
  Finds a single occurrence of data in a database using <code>TableNames</code>
  and <code>MatchFieldSpecs</code> parameters.</td></tr>
<tr><td valign="top"><a href="#find_one-4">find_one/4</a></td><td>
  Finds a single occurrence of data in a database using <code>TableNames</code>,
  <code>MatchFieldSpecs</code> and <code>Options</code> parameters.</td></tr>
<tr><td valign="top"><a href="#insert-2">insert/2</a></td><td>
  Inserts data using a <code>TableSpec</code> into a database.</td></tr>
<tr><td valign="top"><a href="#insert-3">insert/3</a></td><td>
  Inserts data using a <code>TableSpec</code> and <code>Options</code> into a database.</td></tr>
<tr><td valign="top"><a href="#install_backend-2">install_backend/2</a></td><td>  
Installs a new database backend and start a connection pool for it.</td></tr>
<tr><td valign="top"><a href="#query-3">query/3</a></td><td>
  Makes a query to a database for the specified <code>DBSession</code>.</td></tr>
<tr><td valign="top"><a href="#query-4">query/4</a></td><td>
  Makes a query to a database for the specified <code>DBSession</code> using
  <code>Options</code> to extend the functionality.</td></tr>
<tr><td valign="top"><a href="#remove_backend-1">remove_backend/1</a></td><td>
  Removes a database backend specified by <code>BackendName</code> parameter.</td></tr>
<tr><td valign="top"><a href="#transaction-2">transaction/2</a></td><td>
  Prepares a transaction context for the specified <code>DBSession</code>.</td></tr>
<tr><td valign="top"><a href="#update-3">update/3</a></td><td>
  Updates data in a database using a <code>TableSpec</code> and
  <code>MatchFieldSpecs</code> parameters.</td></tr>
<tr><td valign="top"><a href="#update-4">update/4</a></td><td>
  Updates data in a database using a <code>TableSpec</code>, <code>MatchFieldSpec</code>
  and <code>Options</code>, parameters.</td></tr>
<tr><td valign="top"><a href="#update_backend_options-2">update_backend_options/2</a></td><td>  
Updates a backend configuration.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="connect-1">connect/1</a></h3>
<div class="spec">
<p><tt>connect(BackendName) -&gt; {ok, DBSession} | {error, {invalid_backend, BackendName}} | {error, Other}</tt>
<ul class="definitions"><li><tt>BackendName = atom()</tt></li><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Tries to connect to a database backend. Returns a <code>DBSession</code>  
with information about the backend and connection.</p>
 
  <p>Warning: using this function is not recommended unless you know
  what you are doing, because it will create a connection outside of
  the connection pool. Use <code>connection_block/1/2</code> instead to get an  
available connection from the pool.</p>
 
  Note:<ul>
  <li>
    <code>DBSession</code> is used by many of the API functions.</li>
  <li>
    It uses the backend <code>wait_for_reusable_connection_timeout</code>
    option as a connection timeout.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
    variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre></p>
<p><b>See also:</b> <a href="#connect-2">connect/2</a>.</p>

<h3 class="function"><a name="connect-2">connect/2</a></h3>
<div class="spec">
<p><tt>connect(BackendName, Timeout) -&gt; {ok, DBSession} | {error, {invalid_backend, BackendName}} | {error, Other}</tt>
<ul class="definitions"><li><tt>BackendName = atom()</tt></li><li><tt>Timeout = timeout() | default_timeout</tt></li><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Tries to connect to a database backend within a <code>Timeout</code>.
  Returns a <code>DBSession</code> with information about the backend and  
connection.</p>
 
  <p>Warning: using this function is not recommended unless you know
  what you are doing, because it will create a connection outside of
  the connection pool. Use <code>connection_block/1/2</code> instead to get an  
available connection from the pool.</p>
 
  Note:<ul>
  <li>
    <code>DBSession</code> is used by many of the API functions.</li>
  <li>
    It uses a <code>Timeout</code> in milliseconds to wait for connection. It
    overrides <code>wait_for_reusable_connection_timeout</code> backend
    option.</li>
  <li>
    You can set <code>Timeout = default_timeout</code> to use the backend's
    <code>wait_for_reusable_connection_timeout</code> option.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
    variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre></p>

<h3 class="function"><a name="connection_block-1">connection_block/1</a></h3>
<div class="spec">
<p><tt>connection_block(Fun) -&gt; FunReply | {error, {invalid_backend, BackendName}} | {error, no_available_connection}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>FunReply = any()</tt></li></ul></p>
</div><p><p>
  Tries to create a connection session with an available connection
  from the connection pool for the <code>main_backend</code> backend, and
  executes the function in <code>Fun</code> passing <code>DBSession</code> as argument.</p>
 
  <p>Returns <code>{error, no_available_connection}</code> if a connection from the  
pool cannot be resolved at the moment or it cannot connect to the  
server database.</p>
 
  Example:
  <pre>
    connection_block(fun(DBSession)-&gt; ... end).
  </pre>
  Note:<ul>
  <li>
    It uses the backend's <code>wait_for_reusable_connection_timeout</code>
    option as a connection timeout.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
    variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre>
  Equivalent to:
  <pre>
    connection_block(Fun, []).
  </pre></p>
<p><b>See also:</b> <a href="#connection_block-2">connection_block/2</a>.</p>

<h3 class="function"><a name="connection_block-2">connection_block/2</a></h3>
<div class="spec">
<p><tt>connection_block(Fun, Options) -&gt; FunReply | {error, {invalid_backend, BackendName}} | {error, no_available_connection}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>FunReply = any()</tt></li></ul></p>
</div><p><p>
  Tries to create connection session with an available connection
  from the connection pool for the specified <code>BackendName</code> in
  <code>Options</code>, and executes the function in <code>Fun</code> passing <code>DBSession</code>  
as argument.</p>
 
  <p>Returns <code>{error, no_available_connection}</code> if a connection from the  
pool cannot be resolved at the moment or it cannot connect to the  
server database.</p>
 
  It uses a <code>timeout</code> option in milliseconds to wait for an available
  connection which overrides <code>wait_for_reusable_connection_timeout</code>
  backend option.
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
    {timeout, Timeout :: timeout() | default_timeout}</pre>
  Example:
  <pre>
    connection_block(fun(DBSession)-&gt; ... end,
        [{backend, my_backend}, {timeout, default_timeout}]).
  </pre>
  Note:<ul>
  <li>
    You can set <code>{timeout, default_timeout}</code> to use the backend's
    <code>wait_for_reusable_connection_timeout</code> option.</li>
  <li>
    If the backend options is not specified <code>main_backend</code> config
    will be used.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
    variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre></p>

<h3 class="function"><a name="connection_block_transaction-1">connection_block_transaction/1</a></h3>
<div class="spec">
<p><tt>connection_block_transaction(Fun) -&gt; FunReply | {error, {invalid_backend, BackendName}} | {error, no_available_connection}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>FunReply = any()</tt></li></ul></p>
</div><p><p>
  Tries to create a connection session and a database transaction
  context with an available connection from the connection pool for
  the <code>main_backend</code> backend, and executes the function in <code>Fun</code>
  passing <code>DBSession</code> as argument.</p>
 
  <p>Returns <code>{error, no_available_connection}</code> if a connection from the  
pool cannot be resolved at the moment or it cannot connect to the  
server database.</p>
 
  Example:
  <pre>
    connection_block_transaction(fun(DBSession)-&gt; ... end).
  </pre>
  Note:<ul>
  <li>
    It uses the backend <code>wait_for_reusable_connection_timeout</code>
    option as a connection timeout.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
    variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre>
  Equivalent to:
  <pre>
    connection_block_transaction(Fun, []).
  </pre></p>
<p><b>See also:</b> <a href="#connection_block_transaction-2">connection_block_transaction/2</a>.</p>

<h3 class="function"><a name="connection_block_transaction-2">connection_block_transaction/2</a></h3>
<div class="spec">
<p><tt>connection_block_transaction(Fun, Options) -&gt; FunReply | {error, {invalid_backend, BackendName}} | {error, no_available_connection}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>FunReply = any()</tt></li></ul></p>
</div><p><p>
  Tries to create a connection session and a database transaction
  context with an available connection from the connection pool for
  the specified <code>BackendName</code> in <code>Options</code>, and executes the function
  in <code>Fun</code> passing <code>DBSession</code> as argument.</p>
 
  <p>Returns <code>{error, no_available_connection}</code> if a connection from the  
pool cannot be resolved at the moment or it cannot connect to the  
server database.</p>
 
  It uses a <code>timeout</code> option in milliseconds to wait for an available
  connection which overrides <code>wait_for_reusable_connection_timeout</code>
  backend option.
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
    {timeout, Timeout :: timeout() | default_timeout}</pre>
  Example:
  <pre>
    connection_block_transaction(fun(DBSession)-&gt; ... end,
        [{backend, my_backend}, {timeout, default_timeout}]).
  </pre>
  Note:<ul>
  <li>
    You can set <code>{timeout, default_timeout}</code> to use the backend's
    <code>wait_for_reusable_connection_timeout</code> option.</li>
  <li>
    If the backend options is not specified <code>main_backend</code> config
    will be used.</li>
  <li>
    The backend is configured in <code>cowboy_enhancer</code> environment
     variable called <code>database_manager</code>. i.e.:</li></ul>
  <pre>
     {database_manager, [
         {main_backend, [
             {backend, postgres_backend},
             {server, "localhost"},
             {username, "postgres"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 10}, % 10 connections.
             {wait_for_reusable_connection_timeout, 5000} % 5 sec.
         ]}
     ]}
  </pre></p>

<h3 class="function"><a name="delete-3">delete/3</a></h3>
<div class="spec">
<p><tt>delete(DBSession, TableName, MatchFieldSpecs) -&gt; {ok, Count} | {error, Reason}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="#type-match_field_specs">match_field_specs()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Deletes data from a database using a <code>TableName</code> and
  <code>MatchFieldSpecs</code> parameters.</p>
 
  <code>MatchFieldSpecs</code> is used to match against a sort of records to
  delete. Its structure is as follows:<br>
  <pre>    [condition_term(), ...] |
    [condition_term(), logic_operator(), condition_term()]</pre><p>
  If the <code>logic_operator()</code> is omitted between two <code>condition_term()</code>
  i.e.: <code>[condition_term(), condition_term(), ...]</code> then the <code>and</code>  
logic operator will be used.</p>
 
  You can also group <code>condition_term()</code> to apply a logic operator to
  it. i.e.:
  <pre>    [[condition_term(), ...], logic_operator(), ...]</pre><p>
  You can use a lot of combinations while you bear in mind that some
  logic operators require two <code>condition_term()</code> in each side and
  others like <code>not</code> require only one.</p>
 
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N} =
            database_manager:delete(DBSession, users,
                [{name, 'eq', "john"}, {age, 'gt', 30}])
    end).
  </pre>
  Meaning: delete all <code>users</code> records with <code>name = "john"</code> and <code>age</code>
           greater than <code>30</code>.
 </p>
<p><b>See also:</b> <a href="#delete-3">delete/3</a>.</p>

<h3 class="function"><a name="delete-4">delete/4</a></h3>
<div class="spec">
<p><tt>delete(DBSession, TableName, MatchFieldSpecs, Options) -&gt; {ok, Count} | {ok, Count, <a href="#type-result_data">result_data()</a>} | {error, {invalid_result_format, term()}} | {error, Other}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="#type-match_field_specs">match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Deletes data from a database using a <code>TableName</code>, <code>MatchFieldSpecs</code>
  and <code>Options</code> parameters.</p>
 
  <code>MatchFieldSpecs</code> is used to match against a sort of records to
  delete. Its structure is as follows:<br>
  <pre>    [condition_term(), ...] |
    [condition_term(), logic_operator(), condition_term()]</pre><p>
  If the <code>logic_operator()</code> is omitted between two <code>condition_term()</code>
  i.e.: <code>[condition_term(), condition_term(), ...]</code> then the <code>and</code>  
logic operator will be used.</p>
 
  You can also group <code>condition_term()</code> to apply a logic operator to
  it. i.e.:
  <pre>    [[condition_term(), ...], logic_operator(), ...]</pre><p>
  You can use a lot of combinations while you bear in mind that some
  logic operators require two <code>condition_term()</code> in each side and
  others like <code>not</code> require only one.</p>
 
  Use <code>Options</code> to extend the functionality of the delete function.
  <h5><a name="Options">Options</a></h5>
  <pre>    {return_fields,
        [field_name(), ...] | ['*']}
 
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N, [#{id := Id} |_]} =
            database_manager:delete(DBSession, users,
                [{name, 'eq', "john"}, {age, 'gt', 30}],
                [{return_fields, [id]}, {result_format, map}])
    end).
  </pre><p>
  Meaning: delete all <code>users</code> records with <code>name = "john"</code> and <code>age</code>
           greater than <code>30</code>, returning its ids.</p>
 
  Note:<ul>
  <li>
   You will only get <code>result_data()</code> when using <code>return_fields</code>
   option.</li></ul></p>

<h3 class="function"><a name="disconnect-1">disconnect/1</a></h3>
<div class="spec">
<p><tt>disconnect(DBSession) -&gt; ok</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li></ul></p>
</div><p>
  Disconnects from the specified <code>DBSession</code>.</p>

<h3 class="function"><a name="find-3">find/3</a></h3>
<div class="spec">
<p><tt>find(X1, TableNames, MatchFieldSpecs) -&gt; any()</tt></p>
</div><p><p>
  Finds data in a database using <code>TableNames</code> and <code>MatchFieldSpecs</code>  
parameters.</p>
 
  Equivalent:
  <pre>    find(DBSession, TableNames, MatchFieldSpecs, []).</pre></p>
<p><b>See also:</b> <a href="#find-4">find/4</a>.</p>

<h3 class="function"><a name="find-4">find/4</a></h3>
<div class="spec">
<p><tt>find(DBSession, TableNames, MatchFieldSpecs, Options) -&gt; {ok, <a href="#type-result_data">result_data()</a>} | {error, {invalid_clause_option, term()}} | {error, {invalid_result_format, term()}} | {error, Other}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableNames = atom() | [atom(), ...]</tt></li><li><tt>MatchFieldSpecs = <a href="#type-match_field_specs">match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Finds data in a database using <code>TableNames</code>, <code>MatchFieldSpecs</code> and
  <code>Options</code> parameters.</p>
 
  <code>MatchFieldSpecs</code> is used to match against a sort of records to
  find. Its structure is as follows:<br>
  <pre>    #{}              %% you an use a map for matching.
    [condition_term(), ...] |
    [condition_term(), logic_operator(), condition_term()]</pre><p>
  If the <code>logic_operator()</code> is omitted between two <code>condition_term()</code>
  i.e.: <code>[condition_term(), condition_term(), ...]</code> then the <code>and</code>  
logic operator will be used.</p>
 
  You can also group <code>condition_term()</code> to apply a logic operator to
  it. i.e.:
  <pre>    [[condition_term(), ...], logic_operator(), ...]</pre><p>
  You can use a lot of combinations while you bear in mind that some
  logic operators require two <code>condition_term()</code> in each side and
  others like <code>not</code> require only one.</p>
 
  Use <code>Options</code> to extend the functionality of the find function.
  <h5><a name="Options">Options</a></h5>
  <pre>    {limit, Limit :: pos_integer()} %% Limits the number of records
                                       returned by find.
 
    {offset, Offset :: pos_integer()} %% Returns records starting by
                                         'Offset'.
 
    {order_by, order_by_expr()} %% Orders the result data by
                                   specific fields.
 
    {group_by, group_by_expr()} %% Groups the result data by
                                   specific fields.
 
    {return_fields,
        [field_name() | full_field_name() |
         {TableName, [field_name(), ...]}, ...]}
 
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example with maps:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, #{id := Id}} =
            database_manager:find(DBSession, users,
                #{name =&gt; "Steven", age =&gt; 10},
                [{return_fields, [id]}, {limit, 1}])
    end).
  </pre>
  Example 2:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, #{id := Id}} =
            database_manager:find(DBSession, users,
                [{name, 'eq', "john"}, {age, 'gt', 30}],
                [{return_fields, [id]}, {limit, 1}])
    end).
  </pre><p>
  Meaning: find data from <code>users</code> table which <code>name = "john"</code> and <code>age</code>
           greater than <code>30</code>, returning its id and limiting the result           
to one record.</p>
 
  Example 3:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, #{user_id := UserId, role_id := RoleID}} =
            database_manager:find(DBSession, [users, roles]
                [{{users, level}, '==', {roles, role_level}}],
                [{return_fields,
                    [{users, id, user_id}, {roles, id, role_id}]}])
    end).
  </pre><p>
  Meaning: find data from <code>users</code> and <code>roles</code> tables where <code>level</code>
           column from <code>users</code> match with <code>role_level</code> column from
           <code>roles</code> table, it also does returns the id of both table           
records with an user defined alias for each one of them.</p>
 
  Note:<ul>
  <li>
   To use <code>*</code> simple enclose it between <code>' '</code>. i.e.:
   <pre>     {return_fields, ['*']} or
     {return_fields, [users, ['*']]} or
     {return_fields, [{users, '*'}]}</pre></li></ul></p>

<h3 class="function"><a name="find_one-3">find_one/3</a></h3>
<div class="spec">
<p><tt>find_one(X1, TableNames, MatchFieldSpecs) -&gt; any()</tt></p>
</div><p><p>
  Finds a single occurrence of data in a database using <code>TableNames</code>
  and <code>MatchFieldSpecs</code> parameters.</p>
 
  Equivalent:
  <pre>    find(DBSession, TableNames, MatchFieldSpecs, [{limit, 1}]).</pre></p>
<p><b>See also:</b> <a href="#find-4">find/4</a>.</p>

<h3 class="function"><a name="find_one-4">find_one/4</a></h3>
<div class="spec">
<p><tt>find_one(X1, TableNames, MatchFieldSpecs, Options) -&gt; any()</tt></p>
</div><p><p>
  Finds a single occurrence of data in a database using <code>TableNames</code>,
  <code>MatchFieldSpecs</code> and <code>Options</code> parameters.</p>
 
  Equivalent:
  <pre>    find(DBSession, TableNames, MatchFieldSpecs,
        [{limit, 1} | Options]).</pre></p>
<p><b>See also:</b> <a href="#find-4">find/4</a>.</p>

<h3 class="function"><a name="insert-2">insert/2</a></h3>
<div class="spec">
<p><tt>insert(DBSession, TableSpec) -&gt; {ok, Count} | {error, Reason}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableSpec = <a href="#type-table_spec">table_spec()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Inserts data using a <code>TableSpec</code> into a database.</p>
 
  <code>TableSpec</code> has the following structure:<br>
  <pre>    {table_name, FieldMap :: map()}</pre><p>
  <code>FieldMap</code> is a map with the fields names and values.</p>
 
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, 1} =
            database_manager:insert(DBSession,
                {users, #{name =&gt; "john"}})
    end).
  </pre>
  Note:<ul>
  <li>
    You set in a <code>TableSpec</code> a value of a field equal to another
    field name in order to get the same value of the specified
    field name. The order in the expression does not matter. i.e.:
    <pre>    {users, #{
        name =&gt; "john",
        password =&gt; "server",
        old_password = password}}</pre></li></ul>
  Equivalent to:
  <pre>
    insert(DBSession, TableSpec, []).
  </pre></p>
<p><b>See also:</b> <a href="#insert-3">insert/3</a>.</p>

<h3 class="function"><a name="insert-3">insert/3</a></h3>
<div class="spec">
<p><tt>insert(DBSession, TableSpec, Options) -&gt; {ok, Count} | {ok, Count, <a href="#type-result_data_for_insert">result_data_for_insert()</a>} | {error, {invalid_result_format, term()}} | {error, Other}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableSpec = <a href="#type-table_spec">table_spec()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Inserts data using a <code>TableSpec</code> and <code>Options</code> into a database.</p>
 
  <code>TableSpec</code> has the following structure:<br>
  <pre>    {table_name, FieldMap :: map()}</pre>
  <code>FieldMap</code> is a map with the fields names and values.
  <h5><a name="Options">Options</a></h5>
  <pre>    {return_fields,
        [field_name(), ...] | ['*']}
 
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example 1: <code>{result_format, map}</code>.
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, 1, #{id := Id}} =
            database_manager:insert(DBSession,
                {users, #{name =&gt; "john"}},
                    [{return_fields, [id]}, {result_format, map}])
    end).
  </pre>
  Example 2: <code>{result_format, proplist}</code>.
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, 1, [[{id, Id}]] =
            database_manager:insert(DBSession,
                {users, #{name =&gt; "john"}},
                    [{return_fields, [id]},
                     {result_format, proplist}])
    end).
  </pre>
  Note:<ul>
  <li>
    You set in a <code>TableSpec</code> a value of a field equal to another
    field name in order to get the same value of the specified
    field name. The order in the expression does not matter. i.e.:
    <pre>    {users, #{
        name =&gt; "john",
        password =&gt; "server",
        old_password = password}}</pre></li>
  <li>
    The field data returned depends on <code>result_format</code> options.
    i.e.: for <code>map</code> is map containing the field names and values,
    and for <code>proplist</code> is a proplist with the field names and
    values inside a list for erlydtl compatibility aspects.</li>
  <li>
    If no <code>result_format</code> is specified, <code>map</code> will be the default
    result format.</li></ul></p>

<h3 class="function"><a name="install_backend-2">install_backend/2</a></h3>
<div class="spec">
<p><tt>install_backend(BackendName, Options) -&gt; ok | error | {error, Other}</tt>
<ul class="definitions"><li><tt>BackendName = atom()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>  
Installs a new database backend and start a connection pool for it.</p>
 
  Example:
  <pre>
    ok = install_backend(my_backend, [
             {backend, mnesia_backend},
             {server, "localhost"},
             {username, "test"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 5},
             {wait_for_reusable_connection_timeout, 5000}]).
  </pre>
  Note:<ul>
  <li>
    It is possible to omit <code>max_reusable_connections</code> and
    <code>wait_for_reusable_connection_timeout</code> options, default values
    will be provided.</li></ul></p>

<h3 class="function"><a name="query-3">query/3</a></h3>
<div class="spec">
<p><tt>query(DBSession, Query, Params) -&gt; {ok, <a href="#type-map_result_data">map_result_data()</a>} | {ok, Count} | {ok, Count, <a href="#type-map_result_data">map_result_data()</a>} | {error, Reason}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>Query = string() | bitstring()</tt></li><li><tt>Params = <a href="#type-query_params">query_params()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Makes a query to a database for the specified <code>DBSession</code>.</p>
 
  Returns:
  <pre>    {ok, Data} %% when using 'select'.
    {ok, Count} % when using 'update', 'insert', 'delete'.
    {ok, Count, Data} %% when using 'update', 'insert', 'delete'
                         with returning.</pre>
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N, [#{id := Id, name := Name} |_]} =
            database_manager:query(DBSession,
                "SELECT users.id, users.name FROM users
                    WHERE name=$1 and age=$2",
                ["John", 31])
    end).
  </pre>
  Note:<ul>
  <li>
    Result data will be in map format.</li></ul></p>
<p><b>See also:</b> <a href="#query-4">query/4</a>.</p>

<h3 class="function"><a name="query-4">query/4</a></h3>
<div class="spec">
<p><tt>query(DBSession, Query, Params, Options) -&gt; {ok, <a href="#type-result_data">result_data()</a>} | {ok, Count} | {ok, Count, <a href="#type-result_data">result_data()</a>} | {error, {invalid_result_format, term()}} | {error, Other}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>Query = string() | bitstring()</tt></li><li><tt>Params = <a href="#type-query_params">query_params()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Makes a query to a database for the specified <code>DBSession</code> using
  <code>Options</code> to extend the functionality.</p>
 
  Returns a <code>ResultData</code>, it depends of <code>result_format</code> Option,
  <code>result_format</code> could be one of <code>raw</code>, <code>map</code>, <code>proplist</code>,
  <code>map</code> and <code>proplist</code> result formats have the same
  <code>ResultData</code> struct:
  <pre>    {ok, Data} %% when using 'select'.
    {ok, Count} % when using 'update', 'insert', 'delete'.
    {ok, Count, Data} %% when using 'update', 'insert', 'delete'
                         with returning.</pre>
  The only differences are:
  <pre>    0 result:
        'map' -&gt; no_data,
        'proplist' -&gt; []
    1 result:
        'map' -&gt; a single map #{...},
        'proplist' -&gt; a list of proplist [[...]], (templ. comp.)
    N result:
        'map' -&gt; a list of maps [#{...}, ...],
        'proplist' -&gt; a list of proplists  [[...], ...]</pre>
  <code>raw</code> by the other hand is <code>Backend</code> dependent.
  <h5><a name="Options">Options</a></h5>
  <pre>    {result_format, raw | map | proplist}.</pre>
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N, [#{id := Id, name := Name} |_]} =
            database_manager:query(DBSession,
                "SELECT users.id, users.name FROM users
                    WHERE name=$1 and age=$2",
                ["John", 31], [{result_format, map}])
    end).
  </pre>
  Note:<ul>
  <li>
    All result format has its pros and cons, <code>raw</code> is the fastest
    but backend dependent, <code>map</code> is the slowest but very easy to
    deal with. So this is the performance order from fastest to
    slowest <code>raw</code> &gt; <code>proplist</code> &gt; <code>map</code>.</li>
  <li>
    <code>proplist</code> can be used to return directly to a template, also
    when you need to export the data to the world of other libs or
    through a socket <code>proplist</code> could be the best choice because it
    more standard than <code>map</code>.</li>
  <li>
    If no <code>result_format</code> is specified, <code>map</code> will be the default
    result format.</li></ul></p>

<h3 class="function"><a name="remove_backend-1">remove_backend/1</a></h3>
<div class="spec">
<p><tt>remove_backend(BackendName) -&gt; ok | {error, {invalid_backend, BackendName}} | {error, Other}</tt>
<ul class="definitions"><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Removes a database backend specified by <code>BackendName</code> parameter.</p>
 
  Example:
  <pre>
    ok = remove_backend(my_backend).
  </pre></p>

<h3 class="function"><a name="transaction-2">transaction/2</a></h3>
<div class="spec">
<p><tt>transaction(DBSession, Fun) -&gt; FunReply | {error, Reason}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>Fun = function()</tt></li><li><tt>FunReply = any()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Prepares a transaction context for the specified <code>DBSession</code>.</p>
 
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        database_manager:transaction(DBSession, fun() -&gt;
            {ok, 1} =
                database_manager:query(DBSession,
                    InsertQuery, Params)
        end)
    end).
  </pre></p>

<h3 class="function"><a name="update-3">update/3</a></h3>
<div class="spec">
<p><tt>update(DBSession, TableSpec, MatchFieldSpecs) -&gt; {ok, Count} | {error, Reason}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableSpec = <a href="#type-table_spec">table_spec()</a></tt></li><li><tt>MatchFieldSpecs = <a href="#type-match_field_specs">match_field_specs()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Updates data in a database using a <code>TableSpec</code> and
  <code>MatchFieldSpecs</code> parameters.</p>
 
  <code>TableSpec</code> has the following structure:<br>
  <pre>    {table_name, FieldMap :: map()}</pre><p>
  <code>FieldMap</code> is a map with the fields names and values. It must  
contains only the fields you wish to update.</p>
 
  <code>MatchFieldSpecs</code> is used to match against a sort of records for
  update. Its structure is as follows:<br>
  <pre>    [condition_term(), ...] or
    [condition_term(), logic_operator(), condition_term()]</pre><p>
  If the <code>logic_operator()</code> is omitted between two <code>condition_term()</code>
  then the <code>and</code> logic operator will be used. i.e.: in the second
  clause of the definition of a <code>MatchFieldSpecs</code> where a list of  
condition_term() separated by comma is defined.</p>
 
  You can also group <code>condition_term()</code> to apply a logic operator to
  it. i.e.:
  <pre>    [[condition_term(), ...], logic_operator(), ...]</pre><p>
  You can use a lot of combinations while you bear in mind that some
  logic operators require two <code>condition_term()</code> in each side and
  others like <code>not</code> require only one.</p>
 
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N} =
            database_manager:update(DBSession,
                {users, #{signed =&gt; true}},
                [{name, 'eq', "john"}, {age, 'gt', 30}])
    end).
  </pre><p>
  Meaning: update all records with <code>name = "john"</code> to <code>signed = true</code>
           whose <code>age</code> are greater than <code>30</code>.</p>
 
  Note:<ul>
  <li>
    You set in a <code>TableSpec</code> a value of a field equal to another
    field name in order to get the same value of the specified
    field name. The order in the expression does not matter. i.e.:
    <pre>    {users, #{
        name =&gt; "john",
        password =&gt; "server",
        old_password = password}}</pre></li></ul></p>
<p><b>See also:</b> <a href="#update-4">update/4</a>.</p>

<h3 class="function"><a name="update-4">update/4</a></h3>
<div class="spec">
<p><tt>update(DBSession, TableSpec, MatchFieldSpecs, Options) -&gt; {ok, Count} | {ok, Count, <a href="#type-result_data">result_data()</a>} | {error, {invalid_result_format, term()}} | {error, Other}</tt>
<ul class="definitions"><li><tt>DBSession = <a href="#type-db_session">db_session()</a></tt></li><li><tt>TableSpec = <a href="#type-table_spec">table_spec()</a></tt></li><li><tt>MatchFieldSpecs = <a href="#type-match_field_specs">match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Count = integer()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Updates data in a database using a <code>TableSpec</code>, <code>MatchFieldSpec</code>
  and <code>Options</code>, parameters.</p>
 
  <code>TableSpec</code> has the following structure:<br>
  <pre>    {table_name, FieldMap :: map()}</pre><p>
  <code>FieldMap</code> is a map with the fields names and values. It must  
contains only the fields you wish to update.</p>
 
  <code>MatchFieldSpecs</code> is used to match against a sort of records for
  update. Its structure is as follows:<br>
  <pre>    [condition_term(), ...] or
    [condition_term(), logic_operator(), condition_term()]</pre><p>
  If the <code>logic_operator()</code> is omitted between two <code>condition_term()</code>
  then the <code>and</code> logic operator will be used. i.e.: in the second
  clause of the definition of a <code>MatchFieldSpecs</code> where a list of  
condition_term() separated by comma is defined.</p>
 
  You can also group <code>condition_term()</code> to apply a logic operator to
  it. i.e.:
  <pre>    [[condition_term(), ...], logic_operator(), ...]</pre><p>
  You can use a lot of combinations while you bear in mind that some
  logic operators require two <code>condition_term()</code> in each side and
  others like <code>not</code> require only one.</p>
 
  Use <code>Options</code> to extend the functionality of the update.
  <h5><a name="Options">Options</a></h5>
  <pre>    {return_fields,
        [field_name() | full_field_name() |
         {TableName, [field_name(), ...]}, ...]}
 
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    database_manager:connection_block(fun(DBSession) -&gt;
        {ok, N, [#{id := Id} |_]} =
            database_manager:update(DBSession,
                {users, #{signed =&gt; true}},
                [{name, 'eq', "john"}, {age, 'gt', 30}],
                [{return_fields, [id]}, {result_format, map}])
    end).
  </pre><p>
  Meaning: update all records with <code>name = "john"</code> to <code>signed = true</code>
           whose <code>age</code> are greater than <code>30</code>, returning its ids.</p>
 
  Note:<ul>
  <li>
    You set in a <code>TableSpec</code> a value of a field equal to another
    field name in order to get the same value of the specified
    field name. The order in the expression does not matter. i.e.:
    <pre>    {users, #{
        name =&gt; "john",
        password =&gt; "server",
        old_password = password}}</pre></li>
  <li>
   To use <code>*</code> simple enclose it between <code>' '</code>. i.e.:
   <pre>     {return_fields, ['*']} or
     {return_fields, [users, ['*']]} or
     {return_fields, [{users, '*'}]}</pre></li></ul></p>

<h3 class="function"><a name="update_backend_options-2">update_backend_options/2</a></h3>
<div class="spec">
<p><tt>update_backend_options(BackendName, NewOptions) -&gt; ok | {error, {invalid_backend, BackendName}} | {error, {invalid_options, [atom(), ...]}} | {error, Other}</tt>
<ul class="definitions"><li><tt>BackendName = atom()</tt></li><li><tt>NewOptions = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>  
Updates a backend configuration.</p>
 
  Example:
  <pre>
    ok = update_backend_options(my_backend, [
             {backend, mnesia_backend},
             {server, "localhost"},
             {username, "test"},
             {password, "server"},
             {database, "eoc_db"},
             {max_reusable_connections, 5},
             {wait_for_reusable_connection_timeout, 5000}]).
  </pre></p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Apr 15 2016, 16:38:28.</i></p>
</body>
</html>
