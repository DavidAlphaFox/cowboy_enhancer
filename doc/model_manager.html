<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module model_manager</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module model_manager</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   Manages model creation, update, etc...
<p>Copyright Â© (C) 2015, Ivanco Software</p>

<p><b>Authors:</b> Ivan Carmenates Garcia.</p>

<h2><a name="description">Description</a></h2>
   Manages model creation, update, etc...
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-full_validation_tests">full_validation_tests()</a></h3>
<p><tt>full_validation_tests() = [{ValidationTag::atom(), [<a href="#type-simple_validation_test">simple_validation_test()</a>]}, ...]</tt></p>


<h3 class="typedecl"><a name="type-model_info">model_info()</a></h3>
<p><b>abstract datatype</b>: <tt>model_info()</tt></p>


<h3 class="typedecl"><a name="type-simple_validation_test">simple_validation_test()</a></h3>
<p><tt>simple_validation_test() = {function(), <a href="#type-validation_error_msg">validation_error_msg()</a>}</tt></p>


<h3 class="typedecl"><a name="type-validation_error_msg">validation_error_msg()</a></h3>
<p><tt>validation_error_msg() = term() | string()</tt></p>


<h3 class="typedecl"><a name="type-validation_errors">validation_errors()</a></h3>
<p><tt>validation_errors() = [<a href="#type-validation_error_msg">validation_error_msg()</a>, ...]</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#delete_model-2">delete_model/2</a></td><td>
  Deletes one or many models that match with <code>MatchFieldSpecs</code> from
  the <code>main_backend</code> database backend.</td></tr>
<tr><td valign="top"><a href="#delete_model-3">delete_model/3</a></td><td>
  Deletes one or many models that match with <code>MatchFieldSpecs</code> using
  <code>Options</code> to specify the database backend, connection timeout and  
other options.</td></tr>
<tr><td valign="top"><a href="#delete_model_by_id-2">delete_model_by_id/2</a></td><td>
  Deletes a model represented by its <code>ID</code> from the <code>main_backend</code>  
database backend.</td></tr>
<tr><td valign="top"><a href="#delete_model_by_id-3">delete_model_by_id/3</a></td><td>
  Deletes a model represented by its <code>ID</code>, using <code>Options</code> to specify  
the database backend, connection timeout and other options.</td></tr>
<tr><td valign="top"><a href="#get_model-2">get_model/2</a></td><td>
  Gets a single occurrence of a model that match with
  <code>MatchFieldSpecs</code> parameter from the <code>main_backend</code> database
  backend using a default <code>timeout</code>, at least you specified other  
values in a store block call.</td></tr>
<tr><td valign="top"><a href="#get_model-3">get_model/3</a></td><td>
  Gets one or many occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter using <code>Options</code> to specify the  
database backend or connection timeout, also the result format and  
other options.</td></tr>
<tr><td valign="top"><a href="#get_model_by_id-2">get_model_by_id/2</a></td><td>
  Gets a single occurrence of a model represented by its <code>ID</code>, for
  the <code>main_backend</code> database backend with a default time out.</td></tr>
<tr><td valign="top"><a href="#get_model_by_id-3">get_model_by_id/3</a></td><td>
  Gets a single occurrence a model represented by its <code>ID</code> using
  <code>Options</code> to specify the database backend or connection timeout,  
also the result format and other options.</td></tr>
<tr><td valign="top"><a href="#new_model-2">new_model/2</a></td><td>
  Creates a new model using a map as data-in and tries to validate
  it using <code>always</code> default validation tag.</td></tr>
<tr><td valign="top"><a href="#new_model-3">new_model/3</a></td><td>
  Creates a new model using a map as data-in and tries to validate
  it using more than one validation tag defined in
  <code>validation_tests/1</code>.</td></tr>
<tr><td valign="top"><a href="#query_model-4">query_model/4</a></td><td>
  Does a custom operation with a model and tries to validate it.</td></tr>
<tr><td valign="top"><a href="#select_models-2">select_models/2</a></td><td>
  Retrieves one or more occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter from the <code>main_backend</code> database
  backend using a default <code>timeout</code>, at least you specified other  
values in a store block call.</td></tr>
<tr><td valign="top"><a href="#select_models-3">select_models/3</a></td><td>
  Retrieves one or many occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter using <code>Options</code> to specify the  
database backend or connection timeout, also the result format and  
other options.</td></tr>
<tr><td valign="top"><a href="#store_block-1">store_block/1</a></td><td>
  Creates a store block for the database <code>main_backend</code> with a
  default timeout to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations.</td></tr>
<tr><td valign="top"><a href="#store_block-2">store_block/2</a></td><td>
  Creates a store block to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations, also
  using <code>Options</code> to specify the database backend to use and  
the connection timeout.</td></tr>
<tr><td valign="top"><a href="#store_block_transaction-1">store_block_transaction/1</a></td><td>
  Creates a store block for the database <code>main_backend</code> with a
  default connection timeout to improve performance when using
  multiple consecutive <code>store_model</code> and <code>database_manager</code>  
operations, also creates a database transaction context.</td></tr>
<tr><td valign="top"><a href="#store_block_transaction-2">store_block_transaction/2</a></td><td>
  Creates a store block for a custom database backend and timeout
  specified in <code>Options</code> to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations, also  
creates a database transaction context.</td></tr>
<tr><td valign="top"><a href="#store_model-1">store_model/1</a></td><td>
  Stores a model using <code>ModelInfo</code> into the main_backend database.</td></tr>
<tr><td valign="top"><a href="#store_model-2">store_model/2</a></td><td>
  Stores a model using <code>ModelInfo</code> into the database backend
  specified in <code>Options</code>.</td></tr>
<tr><td valign="top"><a href="#update_model-3">update_model/3</a></td><td>
  Updates a model using a <code>MatchFieldSpecs</code> and a map as data-in to
  update, and tries to validate it using <code>always</code> default validation  
tag.</td></tr>
<tr><td valign="top"><a href="#update_model-4">update_model/4</a></td><td>
  Updates a model using a <code>MatchFieldSpecs</code> and a map as data in to
  update, and tries to validate it using more than one validation
  tags defined in <code>validation_tests/1</code>.</td></tr>
<tr><td valign="top"><a href="#update_model_by_id-3">update_model_by_id/3</a></td><td>
  Updates a model using an <code>Id</code> and a map as data-in to update and
  tries to validate it using <code>always</code> default validation tag.</td></tr>
<tr><td valign="top"><a href="#update_model_by_id-4">update_model_by_id/4</a></td><td>
  Updates a model using an <code>Id</code> and a map as data-in to update and
  tries to validate it using more than one validation tag defined
  in <code>validation_tests/1</code>.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="delete_model-2">delete_model/2</a></h3>
<div class="spec">
<p><tt>delete_model(ModelName, MatchFieldSpecs) -&gt; ok | {ok, {count, Count}} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>Count = pos_integer()</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Deletes one or many models that match with <code>MatchFieldSpecs</code> from
  the <code>main_backend</code> database backend.</p>
 
  Returns:
  <pre>    ok |
    {ok, {count, Count}}</pre><p>
  <code>Count</code> represents the number of occurrences that were deleted.</p>
 
  Example:
  <pre>
    {ok, {count, Count}} =
        model_manager:delete_model(users, [{age =&gt; 20}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#delete_model-3">delete_model/3</a>, <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#delete-4">database_manager:delete/4</a>.</p>

<h3 class="function"><a name="delete_model-3">delete_model/3</a></h3>
<div class="spec">
<p><tt>delete_model(ModelName, MatchFieldSpecs, Options) -&gt; ok | {ok, DeletedModelData | ID} | {ok, {count, Count}} | {ok, [DeletedModelData, ...] | [ID, ...], {count, Count}} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ID = any()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>DeletedModelData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Deletes one or many models that match with <code>MatchFieldSpecs</code> using
  <code>Options</code> to specify the database backend, connection timeout and  
other options.</p>
 
  Returns:
  <pre>    ok |
    {ok, DeletedModelData | ID} |
    {ok, [DeletedModelData, ...] | [ID, ...], {count, Count}}</pre><p>
  <code>DeletedModelData</code> could be a map or a proplist or even raw
  depending on the <code>result_format</code> option.<br>
  <code>Count</code> represents the number of occurrences that were deleted.</p>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For 'return_fields'.
                                 'map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    {ok, DeletedDataList, {count, Count}} =
        model_manager:delete_model(users, #{age =&gt; 20},
             [{backend, main_backend}, {timeout, infinity},
              {return_fields, ['*']}, {result_format, proplist}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#delete-4">database_manager:delete/4</a>.</p>

<h3 class="function"><a name="delete_model_by_id-2">delete_model_by_id/2</a></h3>
<div class="spec">
<p><tt>delete_model_by_id(ModelName, ID) -&gt; ok | {ok, {count, Count}} | {error, {model_without_model_module, ModelModule}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ID = any()</tt></li><li><tt>Count = pos_integer()</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Deletes a model represented by its <code>ID</code> from the <code>main_backend</code>  
database backend.</p>
 
  Example:
  <pre>
    ok = model_manager:delete_model_by_id(users, 1).
  </pre>
  Equivalent to:
  <pre>    delete_model_by_id(ModelName, ID, []).</pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li>
  <li>
   This function may do delete more than one occurrence of a model
   if your id is not unique in the database.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="delete_model_by_id-3">delete_model_by_id/3</a></h3>
<div class="spec">
<p><tt>delete_model_by_id(ModelName, ID, Options) -&gt; ok | {ok, DeletedModelData | ID} | {ok, {count, Count}} | {ok, [DeletedModelData, ...] | [ID, ...], {count, Count}} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ID = any()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>DeletedModelData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Deletes a model represented by its <code>ID</code>, using <code>Options</code> to specify  
the database backend, connection timeout and other options.</p>
 
  Returns:
  <pre>    ok |
    {ok, DeletedModelData | ID} |
    {ok, [DeletedModelData, ...] | [ID, ...], {count, Count}}</pre><p>
  <code>DeletedModelData</code> could be a map or a proplist or even raw
  depending on the <code>result_format</code> option.</p>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For 'return_fields'.
                                 'map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    {ok, DeletedData} =
        model_manager:delete_model_by_id(users, 1,
             [{backend, main_backend}, {timeout, infinity},
              {return_fields, ['*']}, {result_format, proplist}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li>
  <li>
   This function may do delete more than one occurrence of a model
   if your id is not unique in the database.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="get_model-2">get_model/2</a></h3>
<div class="spec">
<p><tt>get_model(ModelName, MatchFieldSpecs) -&gt; {ok, ModelDataMap} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Gets a single occurrence of a model that match with
  <code>MatchFieldSpecs</code> parameter from the <code>main_backend</code> database
  backend using a default <code>timeout</code>, at least you specified other  
values in a store block call.</p>
 
  Returns: <code>{ok, ModelDataMap}</code> which is a map with all model fields
                                and values.
  Example:
  <pre>
    {ok, #{username := Username}} =
        model_manager:get_model(users,
            #{username =&gt; "John", age =&gt; 31}).
  </pre>
  Equivalent to:
  <pre>    get_model(ModelName, MatchFieldSpecs, []).</pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#get_model-3">get_model/3</a>, <a href="#select_models-2">select_models/2</a>, <a href="#select_models-3">select_models/3</a>, <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="get_model-3">get_model/3</a></h3>
<div class="spec">
<p><tt>get_model(ModelName, MatchFieldSpecs, Options) -&gt; {ok, ModelData | [ModelData | MoreModelsData]} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>ModelData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>MoreModelsData = [<a href="database_manager.html#type-result_data">database_manager:result_data()</a>, ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Gets one or many occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter using <code>Options</code> to specify the  
database backend or connection timeout, also the result format and  
other options.</p>
 
  <p>Note that <code>backend</code> and <code>timeout</code> options will be overridden by the  
one you set in a store block call.</p>
 
  <p>Returns: <code>{ok, ModelData}</code> which could be a map or a proplist even
           raw depending on the <code>result_format</code> option.</p>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Note:<ul>
  <li>
   Find out more about Options in <code>database_manager:find/4</code>.
  </li></ul>
  Example:
  <pre>
    {ok, #{username := Username}} =
        model_manager:get_model(users,
            #{username =&gt; "John", age =&gt; 31},
            [{backend, main_backend}, {timeout, infinity}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#select_models-2">select_models/2</a>, <a href="#select_models-3">select_models/3</a>, <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#find-4">database_manager:find/4</a>.</p>

<h3 class="function"><a name="get_model_by_id-2">get_model_by_id/2</a></h3>
<div class="spec">
<p><tt>get_model_by_id(ModelName, ID) -&gt; {ok, ModelDataMap} | {error, {model_without_model_module, ModelModule}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ID = any()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Gets a single occurrence of a model represented by its <code>ID</code>, for
  the <code>main_backend</code> database backend with a default time out.</p>
 
  Returns:
  <pre>    {ok, ModelDataMap}</pre><p>
  <code>ModelDataMap</code> is a map containing all model fields and values.</p>
 
  Example:
  <pre>
    {ok, #{username := Username}} =
        model_manager:get_model_by_id(users, 1).
  </pre>
  Equivalent to:
  <pre>    get_model_by_id(ModelName, ID, []).</pre>
  Note:<ul>
  <li>
   This function can be used inside a store block.</li></ul></p>
<p><b>See also:</b> <a href="#get_model_by_id-3">get_model_by_id/3</a>, <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="get_model_by_id-3">get_model_by_id/3</a></h3>
<div class="spec">
<p><tt>get_model_by_id(ModelName, ID, Options) -&gt; {ok, ModelData} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ID = any()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>ModelData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Gets a single occurrence a model represented by its <code>ID</code> using
  <code>Options</code> to specify the database backend or connection timeout,  
also the result format and other options.</p>
 
  Returns:
  <pre>    {ok, ModelData}</pre><p>
  <code>ModelData</code> could be a map or a proplist or even raw depending on
              the <code>result_format</code> option.</p>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Note:<ul>
  <li>
   Find out more about Options in database_manager:find/4.
  </li></ul>
  Example:
  <pre>
    {ok, #{username := Username}} =
        model_manager:get_model_by_id(users, 1,
            [{backend, main_backend}, {timeout, infinity},
                {result_format, proplist}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="new_model-2">new_model/2</a></h3>
<div class="spec">
<p><tt>new_model(ModelName, ModelDataMap) -&gt; {ok, <a href="#type-model_info">model_info()</a>} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a new model using a map as data-in and tries to validate
  it using <code>always</code> default validation tag.</p>
 
  Returns:
  <pre>    {ok, ModelInfo}</pre><p>
  <code>ModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of <code>new_model/2/3</code>
   function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module, function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        {username := Username} = ModelDataMap,
        [
            {always, [
                %% username is required
                {fun() -&gt;
                    size(Username) =/= 0
                end, "username cannot be empty"}
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    ModelDataMap = #{username =&gt; "John", age =&gt; 31},
    {ok, ModelInfo} = model_manager:new_model(users, ModelDataMap).
  </pre>
  Equivalent to:
  <pre>    new_model(ModelName, ModelDataMap, []).</pre></p>
<p><b>See also:</b> <a href="#new_mode-3">new_mode/3</a>, <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>.</p>

<h3 class="function"><a name="new_model-3">new_model/3</a></h3>
<div class="spec">
<p><tt>new_model(ModelName, ModelDataMap, ValidationTags) -&gt; {ok, <a href="#type-model_info">model_info()</a>} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ValidationTags = [atom(), ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a new model using a map as data-in and tries to validate
  it using more than one validation tag defined in
  <code>validation_tests/1</code>.</p>
 
  <p>Validation tags are the way of doing validation by context, you can  
use a set of validation functions for creating a new model and  
another set of validation functions for updating it, you can also  
define a common sort of validation tests for both scenarios.</p>
 
  Returns:
  <pre>    {ok, ModelInfo}</pre><p>
  <code>ModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of <code>new_model/2/3</code>
   function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        {username := Username, online := Online,
         password := Password} = ModelDataMap,
        [
            {common, [
                %% username is required
                {fun() -&gt;
                    size(Username) =/= 0
                end, "username cannot be empty"}
            ]},
            {new, [
                %% password cannot be empty
                {fun() -&gt;
                    size(Password) =/= 0
                end, "password cannot be empty"}
            ]},
            {update, [
                %% online must be true or false
                {fun() -&gt;
                    (Online == true) or (Online == false)
                end, "online is not true or false"}
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    ModelDataMap = #{username =&gt; "John", password =&gt; "1eAfG6"},
    {ok, ModelInfo} =
        model_manager:new_model(users, ModelDataMap, [common, new]).
 
    NewModelDataMap = #{username =&gt; "John C", online =&gt; true},
    {ok, NewModelInfo} =
        model_manager:update_model_by_id(users, Id,
            NewModelDataMap, [common, update]).
  </pre>
  Note:<ul>
  <li>
   <code>always</code> validation tag will be always used if exist.</li></ul></p>
<p><b>See also:</b> <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>.</p>

<h3 class="function"><a name="query_model-4">query_model/4</a></h3>
<div class="spec">
<p><tt>query_model(ModelName, ModelDataMap, ValidationTags, Fun) -&gt; FunResult | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ValidationTags = [atom(), ...]</tt></li><li><tt>Fun = function()</tt></li><li><tt>FunResult = {ok, any()} | {error, term()}</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Does a custom operation with a model and tries to validate it.
  You can use more than one validation tag defined in
  <code>validation_tests/1</code>.</p>
 
  <p>Validation tags are the way of doing validation by context, you can  
use a set of validation functions for creating a new model and  
another set of validation functions for updating it, you can also  
define a common sort of validation tests for both scenarios.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of
   <code>update_model/3/4</code> function call.</li>
  <li>
   Function in <code>Fun</code> must return either of <code>{ok, any()}</code> or
   <code>{error, term()}</code>.</li></ul>
  Example:
  <pre>
    model_manager:query_model(users, ModelDataMap, [common, other],
        fun(ModelName, ModelModule, ModelData) -&gt;
            {ok, Result} = ...
        end).
  </pre>
  NOTE: <code>always</code> validation tag will be always used if exist.</p>

<h3 class="function"><a name="select_models-2">select_models/2</a></h3>
<div class="spec">
<p><tt>select_models(ModelName, MatchFieldSpecs) -&gt; {ok, ModelDataMap | [ModelDataMap | MoreModels]} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>MoreModels = [#{}, ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Retrieves one or more occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter from the <code>main_backend</code> database
  backend using a default <code>timeout</code>, at least you specified other  
values in a store block call.</p>
 
  <p>Returns: <code>{ok, ModelDataMap | [ModelDataMap, ...]}</code> which is a map           
with all model fields and values.</p>
 
  Example:
  <pre>
    {ok, [#{username := Username} | MoreModels]} =
        model_manager:get_model(users,
            #{username =&gt; "John", age =&gt; 31}).
  </pre>
  Equivalent to:
  <pre>    get_model(ModelName, MatchFieldSpecs, []).</pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#get_model-3">get_model/3</a>, <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>.</p>

<h3 class="function"><a name="select_models-3">select_models/3</a></h3>
<div class="spec">
<p><tt>select_models(ModelName, MatchFieldSpecs, Options) -&gt; {ok, ModelData | [ModelData | MoreModelsData]} | {error, {model_without_model_module, ModelModule}} | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>ModelData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>MoreModelsData = [<a href="database_manager.html#type-result_data">database_manager:result_data()</a>, ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Retrieves one or many occurrences of a model that match with
  <code>MatchFieldSpecs</code> parameter using <code>Options</code> to specify the  
database backend or connection timeout, also the result format and  
other options.</p>
 
  <p>Note that <code>backend</code> and <code>timeout</code> options will be overridden by the  
one you set in a store block call.</p>
 
  <p>Returns: <code>{ok, ModelData | [ModelData, ...]}</code> which could be a map
            or a proplist even raw depending on the <code>result_format</code>            
option.</p>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For `return_fields'.
                                 `map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Note:<ul>
  <li>
   Find out more about Options in <code>database_manager:find/4</code>.
  </li></ul>
  Example:
  <pre>
    {ok, [#{username := Username} | MoreModels]} =
        model_manager:get_model(users,
            #{username =&gt; "John", age =&gt; 31},
            [{backend, main_backend}, {timeout, infinity}]).
  </pre>
  Note:<ul>
  <li>
   This function can be used inside of a store block call.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#find-4">database_manager:find/4</a>.</p>

<h3 class="function"><a name="store_block-1">store_block/1</a></h3>
<div class="spec">
<p><tt>store_block(Fun) -&gt; any() | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a store block for the database <code>main_backend</code> with a
  default timeout to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations.</p>
 
  Note:<ul>
  <li>
   To use another database backend or timeout use
   <code>store_block/2</code>.</li>
  <li>
   <code>store_block/1/2</code> does not execute in transaction mode,
   for that propose use <code>store_block_transaction/1/2</code>.</li></ul>
  Equivalent to:
  <pre>    store_block(Fun, []).</pre>
  Example:
  <pre>
    model_manager:store_block(fun(_DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo, [return_id]),
        {ok, ModelInfo2} = model_manager:new_model(user_blogs, #{
                               {user_id =&gt; ID, blog_name =&gt; "test"}),
        ok = model_manager:store_model(ModelInfo2)
    end).
  </pre>
 
  Note:<ul>
  <li>
   You can mix between high level <code>model_manager</code> functions and
   low level <code>database_manager</code> functions inside a store block
   using <code>DBSession</code> variable passed to the store block fun
  </li></ul><p>.</p>
 
  Example2:
  <pre>
    model_manager:store_block(fun(DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        database_manager:insert(DBSession,
            {user_messages, #{user_id =&gt; ID, message =&gt; "new user"})
    end).
  </pre>
 
  WARNING:<ul>
  <li>
   Inside of a store block the backend option and timeout of a
   <code>store_model</code> call will be overridden by the one specified in
   the <code>store_block/1/2</code> function call.</li>
  <li>
   Do not use different processes inside a store block.</li></ul>
 
  Note:<ul>
  <li>
    Using nested store blocks has no effect since only the
    first one creates the session and the others reuses it.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#connection_block-1">database_manager:connection_block/1</a>, <a href="database_manager.html#connection_block-2">database_manager:connection_block/2</a>.</p>

<h3 class="function"><a name="store_block-2">store_block/2</a></h3>
<div class="spec">
<p><tt>store_block(Fun, Options) -&gt; any() | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a store block to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations, also
  using <code>Options</code> to specify the database backend to use and  
the connection timeout.</p>
 
  Note:<ul>
  <li>
   <code>store_block/1/2</code> does not executes in transaction mode,
   for that propose use <code>store_block_transaction/1/2</code>.</li></ul>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For 'return_fields'.
                                 'map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    model_manager:store_block(fun(_DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        {ok, ModelInfo2} = model_manager:new_model(user_blogs, #{
                               {user_id =&gt; ID, blog_name =&gt; "test"}),
        ok = model_manager:store_model(ModelInfo2)
    end, [{backend, main_backend}, {timeout, infinity}]).
  </pre>
 
  Note:<ul>
  <li>
   You can mix between high level <code>model_manager</code> functions and
   low level <code>database_manager</code> functions inside a store block
   using <code>DBSession</code> variable passed to the store block fun.
  </li></ul>
 
  Example2:
  <pre>
    model_manager:store_block(fun(DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        database_manager:insert(DBSession,
            {user_messages, #{user_id =&gt; ID, message =&gt; "new user"})
    end, [{backend, main_backend}, {timeout, infinity}]).
  </pre>
 
  WARNING:<ul>
  <li>
   Inside of a store block the backend option and timeout of a
   <code>store_model</code> call will be overridden by the one specified in
   the <code>store_block/1/2</code> function call.</li>
  <li>
   Do not use different processes inside a store block.</li></ul>
  Note:<ul>
  <li>
   Using nested store blocks has no down-side effects since only
   the first one creates the session and the others reuses it.
  </li></ul></p>

<h3 class="function"><a name="store_block_transaction-1">store_block_transaction/1</a></h3>
<div class="spec">
<p><tt>store_block_transaction(Fun) -&gt; any() | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a store block for the database <code>main_backend</code> with a
  default connection timeout to improve performance when using
  multiple consecutive <code>store_model</code> and <code>database_manager</code>  
operations, also creates a database transaction context.</p>
 
  Note:<ul>
  <li>
   To use another database backend and timeout with transaction
   context use <code>store_block_transaction/2</code>.</li></ul>
  Equivalent to:
  <pre>    store_block_transaction(Fun, []).</pre>
  Example:
  <pre>
    model_manager:store_block_transaction(fun(_DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        {ok, ModelInfo2} = model_manager:new_model(user_blogs, #{
                               {user_id =&gt; ID, blog_name =&gt; "test"}),
        ok = model_manager:store_model(ModelInfo2)
    end).
  </pre>
  Note:<ul>
  <li>
   You can mix between high level <code>model_manager</code> functions and
   low level <code>database_manager</code> functions inside a store block
   using <code>DBSession</code> variable passed to the store block fun.
  </li></ul>
  Example2:
  <pre>
    model_manager:store_block_transaction(fun(DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        database_manager:transaction(DBSession, fun() -&gt;
            database_manager:insert(DBSession, {user_messages,
                #{user_id =&gt; ID, message =&gt; "new user"})
        end)
    end).
  </pre>
  WARNING:<ul>
  <li>
   Inside of a store block the backend option and timeout
   of a <code>store_model</code> call will be overridden by the one
   specified in the <code>store_block_transaction/1/2</code>
   function call.</li>
  <li>
   Do not use different processes inside a store block.
  </li></ul></p>
<p><b>See also:</b> <a href="#store_block_transaction-2">store_block_transaction/2</a>, <a href="database_manager.html#connection_block_transaction-1">database_manager:connection_block_transaction/1</a>, <a href="database_manager.html#connection_block_transaction-2">database_manager:connection_block_transaction/2</a>.</p>

<h3 class="function"><a name="store_block_transaction-2">store_block_transaction/2</a></h3>
<div class="spec">
<p><tt>store_block_transaction(Fun, Options) -&gt; any() | {error, {invalid_backend, BackendName}} | {error, no_available_connection} | {error, Other}</tt>
<ul class="definitions"><li><tt>Fun = function()</tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Creates a store block for a custom database backend and timeout
  specified in <code>Options</code> to improve performance when using multiple
  consecutive <code>store_model</code> and <code>database_manager</code> operations, also  
creates a database transaction context.</p>
 
  Note:<ul>
  <li>
   You can specify in <code>Options</code> the database backend to use and
   the connection timeout.</li></ul>
  Example:
  <pre>
    model_manager:store_block_transaction(fun(_DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        {ok, ModelInfo2} = model_manager:new_model(user_blogs, #{
                               {user_id =&gt; ID, blog_name =&gt; "test"}),
        ok = model_manager:store_model(ModelInfo2)
    end, [{backend, main_backend}, {timeout, infinity}]).
  </pre>
  Note:<ul>
  <li>
   You can mix between high level <code>model_manager</code> functions and low
   level <code>database_manager</code> functions inside a store block using
   <code>DBSession</code> variable passed to the store block fun.</li></ul>
  Example2:
  <pre>
    model_manager:store_block_transaction(fun(DBSession) -&gt;
        {ok, ID} = model_manager:store_model(ModelInfo,
                       [return_id]),
        database_manager:transaction(DBSession, fun() -&gt;
            database_manager:insert(DBSession, {user_messages,
                    #{user_id =&gt; ID, message =&gt; "new user"})
        end)
    end, [{backend, main_backend}, {timeout, infinity}]).
  </pre>
  WARNING:<ul>
  <li>
   Inside of a store block the backend option and timeout of a
   <code>store_model</code> call will be overridden by the one specified in
   the <code>store_block_transaction/1/2</code> function call.</li>
  <li>
   Do not use different processes inside a store block.</li></ul></p>
<p><b>See also:</b> <a href="database_manager.html#connection_block_transaction-1">database_manager:connection_block_transaction/1</a>, <a href="database_manager.html#connection_block_transaction-2">database_manager:connection_block_transaction/2</a>.</p>

<h3 class="function"><a name="store_model-1">store_model/1</a></h3>
<div class="spec">
<p><tt>store_model(ModelInfo) -&gt; ok | {ok, {count, Count}} | {error, Reason}</tt>
<ul class="definitions"><li><tt>ModelInfo = <a href="#type-model_info">model_info()</a></tt></li><li><tt>Count = pos_integer()</tt></li><li><tt>Reason = term()</tt></li></ul></p>
</div><p><p>
  Stores a model using <code>ModelInfo</code> into the main_backend database.</p>
 
  <p><code>ModelInfo</code> is returned by <code>new_model/2/3</code>, <code>update_model/3/4</code> and
  <code>update_model_by_id/3/4</code> functions.</p>
 
  Example:
  <pre>
    ok = model_manager:store_model(ModelInfo).
  </pre>
  Performance Note:<ul>
  <li>
   If you have to use multiple <code>store_model/1/2</code> consecutively you
   should use a store block to hold the same connection for all,
   i.e.:
   <pre>   model_manager:store_block(fun(_DBSession) -&gt;
       {ok, ID} = model_manager:store_model(ModelInfo, [return_id]),
       {ok, ModelInfo2} =
           model_manager:new_model(user_blogs, #{
               {user_id =&gt; ID, blog_name =&gt; "test"}),
       ok = model_manager:store_model(ModelInfo2)
   end).</pre></li></ul>
  Equivalent to:
  <pre>    store_model(ModelInfo, []).</pre></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="#store_model-2">store_model/2</a>.</p>

<h3 class="function"><a name="store_model-2">store_model/2</a></h3>
<div class="spec">
<p><tt>store_model(ModelInfo, Options) -&gt; ok | {ok, FieldData | ID} | {ok, {count, Count}} | {ok, FieldData | ID, {count, Count}} | {ok, NoActionMessage} | {error, {invalid_backend, BackendName}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelInfo = <a href="#type-model_info">model_info()</a></tt></li><li><tt>Options = <a href="proplists.html#type-proplist">proplists:proplist()</a></tt></li><li><tt>ID = any()</tt></li><li><tt>FieldData = <a href="database_manager.html#type-result_data">database_manager:result_data()</a></tt></li><li><tt>Count = pos_integer()</tt></li><li><tt>NoActionMessage = atom()</tt></li><li><tt>BackendName = atom()</tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Stores a model using <code>ModelInfo</code> into the database backend
  specified in <code>Options</code>.</p>
 
  <p><code>ModelInfo</code> is returned by <code>new_model/2/3</code>, <code>update_model/3/4</code> and
  <code>update_model_by_id/3/4</code> functions.</p>
 
  Note:<ul>
  <li>
   The return value depends on <code>Options</code>, if it contains <code>return_id</code>
   then <code>{ok, ID}</code> will be returned. Otherwise if it contains
   <code>{return_fields, FieldNames}</code> it will return <code>{ok, FieldData}</code>.
   <code>FieldData</code> will be in map format if no <code>result_format</code> option
   is specified. Warning: if <code>return_id</code> is used <code>return_fields</code> will
   be ignored.</li>
  <li>
   You can specify in <code>Options</code> the database backend to use and
   the connection timeout. If no backend is specified then
   <code>main_backend</code> will be used.</li></ul>
 
  <h5><a name="Options">Options</a></h5>
  <pre>    {backend, BackendName :: atom()}
 
    {timeout, Timeout :: timeout() | default_timeout}
 
    {return_fields,
        [field_name(), ...] | ['*']}
 
    {return_id}               %% Overrides 'return_fields'
                                 option. Makes the function to return
                                 {ok, ID} |
                                 {ok, [ID, ...], {count, Count}}
    {result_format,
        raw | map | proplist} %% For 'return_fields'.
                                 'map' will be the default
                                 result format if this
                                 options is omitted.</pre>
  Example:
  <pre>
    {ok, ID} =
        model_manager:store_model(ModelInfo, [return_id,
            {backend, main_backend}, {timeout, infinity}]).
 
    ok = model_manager:store_model(ModelInfo,
             [{backend, main_backend}, {timeout, infinity}]).
 
    {ok, #{id := Id, name := Name} =
        model_manager:store_model(ModelInfo,
             [{return_fields, [id, name]}, {result_format, map}]).
  </pre>
  You can return directly to a Django template using
  <code>{result_format, proplist}</code>, i.e.:
  <pre>
    {ok, FieldData} =
        model_manager:store_model(ModelInfo,
             [{return_fields, [id, name]},
              {result_format, proplist}]),
    {ok, Body} = toppage_dtl:render([{model_data, FieldData}]),
  </pre><p>
  Later in the template you can refer to <code>model_data</code> as
  <code>model_data.id</code> and <code>model_data.name</code>.</p>
 
  Performance Note:<ul>
  <li>
   If you have to use multiple <code>store_model/1/2</code> consecutively you
   should use a store block to hold the same connection for all,
   i.e.:
   <pre>   model_manager:store_block(fun(_DBSession) -&gt;
       {ok, ID} = model_manager:store_model(ModelInfo, [return_id]),
       {ok, ModelInfo2} =
           model_manager:new_model(user_blogs, #{
               {user_id =&gt; ID, blog_name =&gt; "test"}),
       ok = model_manager:store_model(ModelInfo2)
   end, [{backend, main_backend}, {timeout, infinity}]).</pre></li></ul>
  WARNING:<ul>
  <li>
   Inside of a store block the backend option and timeout of a
   <code>store_model/2</code> call will be overridden by the one set by the
   <code>store_block/1/2</code> function.</li></ul></p>
<p><b>See also:</b> <a href="#store_block-1">store_block/1</a>, <a href="#store_block-2">store_block/2</a>, <a href="database_manager.html#update-4">database_manager:update/4</a>.</p>

<h3 class="function"><a name="update_model-3">update_model/3</a></h3>
<div class="spec">
<p><tt>update_model(ModelName, ModelDataMap, MatchFieldSpecs) -&gt; {ok, <a href="#type-model_info">model_info()</a>} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Updates a model using a <code>MatchFieldSpecs</code> and a map as data-in to
  update, and tries to validate it using <code>always</code> default validation  
tag.</p>
 
  Returns:
  <pre>    {ok, NewModelInfo}</pre><p>
  <code>NewModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of
   <code>update_model/3/4</code> function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module, function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        {username := Username} = ModelDataMap,
        [
            {always, [
                {fun() -&gt;
                    Age &gt; 0
                end, "Age is invalid"}
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    NewModelDataMap = #{age =&gt; 32},
    {ok, NewModelInfo} =
        model_manager:update_model(users,
            NewModelDataMap, [{id, '==', Id}]).
  </pre>
  Equivalent to:
  <pre>    update_model(ModelName, NewModelDataMap, MatchFieldSpecs, []).</pre>
  Note:<ul>
  <li>
   See <code>database_manager:update/4</code> to learn more about
   <code>MatchFieldSpecs</code>.</li></ul></p>
<p><b>See also:</b> <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>, <a href="#update_model-4">update_model/4</a>, <a href="database_manager.html#update-4">database_manager:update/4</a>.</p>

<h3 class="function"><a name="update_model-4">update_model/4</a></h3>
<div class="spec">
<p><tt>update_model(ModelName, ModelDataMap, MatchFieldSpecs, ValidationTags) -&gt; {ok, <a href="#type-model_info">model_info()</a>} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>MatchFieldSpecs = <a href="database_manager.html#type-match_field_specs">database_manager:match_field_specs()</a></tt></li><li><tt>ValidationTags = [atom(), ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Updates a model using a <code>MatchFieldSpecs</code> and a map as data in to
  update, and tries to validate it using more than one validation
  tags defined in <code>validation_tests/1</code>.</p>
 
  <p>Validation tags are the way of doing validation by context, you can  
use a set of validation functions for creating a new model and  
another set of validation functions for updating it, you can also  
define a common sort of validation tests for both scenarios.</p>
 
  Returns:
  <pre>    {ok, ModelInfo}</pre><p>
  <code>ModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of
   <code>update_model/3/4</code> function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        {username := Username, online := Online,
         password := Password} = ModelDataMap,
        [
            {common, [
                %% username is required
                {fun() -&gt;
                    size(Username) =/= 0
                end, "username cannot be empty"},
            ]},
            {new, [
                %% password cannot be empty
                {fun() -&gt;
                    size(Password) =/= 0
                end, "password cannot be empty"},
            ]},
            {update, [
                %% online must be true or false
                {fun() -&gt;
                    (Online == true) or (Online == false)
                end, "online is not true or false"},
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    NewModelDataMap = #{age =&gt; 32},
    {ok, NewModelInfo} =
        model_manager:update_model(users,
            NewModelDataMap, [{id, '==', Id}], [common, update]).
  </pre>
    or
  <pre>
    ModelDataMap = #{username =&gt; "John", password =&gt; "1eAfG6"},
    {ok, ModelInfo} =
        model_manager:new_model(users, ModelDataMap, [common, new]).
  </pre>
  Note:<ul>
  <li>
   <code>always</code> validation tag will be always used if exist.</li>
  <li>
   See <code>database_manager:update/4</code> to learn more about
   <code>MatchFieldSpecs</code>.</li></ul></p>
<p><b>See also:</b> <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>, <a href="database_manager.html#update-4">database_manager:update/4</a>.</p>

<h3 class="function"><a name="update_model_by_id-3">update_model_by_id/3</a></h3>
<div class="spec">
<p><tt>update_model_by_id(ModelName, Id, ModelDataMap) -&gt; {ok, NewModelInfo} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>Id = any()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>NewModelInfo = <a href="#type-model_info">model_info()</a></tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Updates a model using an <code>Id</code> and a map as data-in to update and
  tries to validate it using <code>always</code> default validation tag.</p>
 
  Returns:
  <pre>    {ok, NewModelInfo}</pre><p>
  <code>NewModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of
   <code>update_model_by_id/3/4</code> function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module, function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        #{age := Age} = ModelDataMap,
        [
            {always, [
                {fun() -&gt;
                    Age &gt; 0
                end, "age is invalid"}
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    NewModelDataMap = #{age =&gt; 32},
    {ok, NewModelInfo} =
        model_manager:update_model_by_id(users, Id, NewModelDataMap).
  </pre>
  Equivalent to:
  <pre>    update_model_by_id(ModelName, Id, NewModelDataMap, []).</pre></p>
<p><b>See also:</b> <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>, <a href="#update_model_by_id-4">update_model_by_id/4</a>.</p>

<h3 class="function"><a name="update_model_by_id-4">update_model_by_id/4</a></h3>
<div class="spec">
<p><tt>update_model_by_id(ModelName, Id, ModelDataMap, ValidationTags) -&gt; {ok, <a href="#type-model_info">model_info()</a>} | {error, {model_without_model_module, ModelModule}} | {error, {validation_errors, ErrorMessages}} | {error, Other}</tt>
<ul class="definitions"><li><tt>ModelName = atom()</tt></li><li><tt>Id = any()</tt></li><li><tt>ModelDataMap = #{}</tt></li><li><tt>ValidationTags = [atom(), ...]</tt></li><li><tt>ModelModule = atom()</tt></li><li><tt>ErrorMessages = <a href="#type-validation_errors">validation_errors()</a></tt></li><li><tt>Other = term()</tt></li></ul></p>
</div><p><p>
  Updates a model using an <code>Id</code> and a map as data-in to update and
  tries to validate it using more than one validation tag defined
  in <code>validation_tests/1</code>.</p>
 
  <p>Validation tags are the way of doing validation by context, you can  
use a set of validation functions for creating a new model and  
another set of validation functions for updating it, you can also  
define a common sort of validation tests for both scenarios.</p>
 
  Returns:
  <pre>    {ok, NewModelInfo}.</pre><p>
  <code>NewModelInfo</code> is used to store the model into the database using
  <code>store_model/1/2</code> function.</p>
 
  Note:<ul>
  <li>
   Function <code>after_validate/1</code> will be executed in the model if it
   is implemented and all validation tests pass successfully. It
   must return <code>ok</code> or <code>{error, Error}</code>. If it returns
   <code>{error, Error}</code> that will be the return value of
   <code>update_model_by_id/3/4</code> function call.</li></ul>
  Example:<br><br>
    In <code>users_model</code> module function <code>validation_tests/1</code>:
  <pre>
    validation_tests(ModelDataMap) -&gt;
        {username := Username, online := Online,
         password := Password} = ModelDataMap,
        [
            {common, [
                %% username is required
                {fun() -&gt;
                    size(Username) =/= 0
                end, "username cannot be empty"},
            ]},
            {new, [
                %% password cannot be empty
                {fun() -&gt;
                    size(Password) =/= 0
                end, "password cannot be empty"},
            ]},
            {update, [
                %% online must be true or false
                {fun() -&gt;
                    (Online == true) or (Online == false)
                end, "online is not true or false"},
            ]}
        ].
  </pre>
    Then in the controller or in another module you can call:
  <pre>
    NewModelDataMap = #{age =&gt; 32},
    {ok, NewModelInfo} =
        model_manager:update_model_by_id(users, Id,
            NewModelDataMap, [common, update]).
 
    ModelDataMap = #{username =&gt; "John", password =&gt; "1eAfG6"},
    {ok, ModelInfo2} =
        model_manager:new_model(users, ModelDataMap, [common, new]).
  </pre>
  Note:<ul>
  <li>
   <code>always</code> validation tag will be always used if exist.</li></ul></p>
<p><b>See also:</b> <a href="#store_model-1">store_model/1</a>, <a href="#store_model-2">store_model/2</a>.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Apr 15 2016, 16:38:28.</i></p>
</body>
</html>
